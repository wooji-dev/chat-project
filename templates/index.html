<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Chat Demo</title>
    <style>
      :root {
        --bg: #f6f8ff;
        --card: #ffffff;
        --text: #0f172a;
        --muted: #64748b;
        --line: #e6eaf5;
        --primary: #2d5bff;
        --shadow: 0 18px 50px rgba(15, 23, 42, 0.08);
        --shadow-soft: 0 10px 30px rgba(15, 23, 42, 0.06);
        --radius: 22px;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          "Noto Sans KR", "Apple SD Gothic Neo", Helvetica, Arial,
          "Segoe UI Emoji";
        color: var(--text);
        background: radial-gradient(
            900px 450px at 10% 10%,
            rgba(45, 91, 255, 0.14),
            rgba(45, 91, 255, 0) 60%
          ),
          radial-gradient(
            850px 400px at 90% 15%,
            rgba(0, 225, 255, 0.12),
            rgba(0, 225, 255, 0) 60%
          ),
          radial-gradient(
            700px 450px at 50% 100%,
            rgba(155, 81, 224, 0.1),
            rgba(155, 81, 224, 0) 60%
          ),
          var(--bg);
        overflow-x: hidden;
      }
      .wrap {
        min-height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 28px 16px;
      }
      .app {
        width: min(980px, 100%);
        display: grid;
        grid-template-columns: 340px 1fr;
        gap: 16px;
      }
      @media (max-width: 900px) {
        .app {
          grid-template-columns: 1fr;
        }
      }
      .panel {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        overflow: hidden;
      }
      .side {
        display: flex;
        flex-direction: column;
        min-height: 560px;
      }
      .hero {
        padding: 18px 18px 16px;
        border-bottom: 1px solid var(--line);
        background: linear-gradient(
            180deg,
            rgba(45, 91, 255, 0.07),
            rgba(45, 91, 255, 0) 65%
          ),
          #fff;
      }
      .brand {
        display: flex;
        align-items: center;
        gap: 12px;
      }
      .logo {
        width: 44px;
        height: 44px;
        border-radius: 16px;
        background: linear-gradient(
          135deg,
          rgba(45, 91, 255, 0.95),
          rgba(0, 225, 255, 0.85)
        );
        box-shadow: 0 12px 30px rgba(45, 91, 255, 0.22);
        display: grid;
        place-items: center;
        color: #fff;
        font-weight: 900;
        letter-spacing: -0.04em;
      }
      .brand h1 {
        margin: 0;
        font-size: 16px;
        letter-spacing: -0.03em;
      }
      .brand p {
        margin: 2px 0 0;
        font-size: 12.5px;
        color: var(--muted);
        line-height: 1.35;
      }

      .profile {
        margin-top: 14px;
        padding: 12px 12px;
        border-radius: 18px;
        border: 1px dashed rgba(45, 91, 255, 0.25);
        background: rgba(45, 91, 255, 0.04);
        display: flex;
        gap: 12px;
        align-items: center;
      }
      .avatar {
        width: 46px;
        height: 46px;
        border-radius: 18px;
        display: grid;
        place-items: center;
        background: #fff;
        border: 1px solid var(--line);
        box-shadow: var(--shadow-soft);
        overflow: hidden;
        flex: 0 0 auto;
      }
      .avatar svg {
        width: 46px;
        height: 46px;
        display: block;
      }
      .profile .meta {
        min-width: 0;
        flex: 1;
      }
      .profile .meta .title {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }
      .badge {
        font-size: 11px;
        padding: 4px 8px;
        border-radius: 999px;
        border: 1px solid rgba(45, 91, 255, 0.2);
        background: rgba(45, 91, 255, 0.08);
        color: rgba(45, 91, 255, 0.95);
        font-weight: 700;
      }
      .profile input {
        width: 100%;
        border: 1px solid var(--line);
        border-radius: 14px;
        padding: 10px 12px;
        font-size: 13px;
        outline: none;
        margin-top: 8px;
        background: #fff;
      }
      .profile input:focus {
        border-color: rgba(45, 91, 255, 0.55);
        box-shadow: 0 0 0 4px rgba(45, 91, 255, 0.1);
      }

      .tips {
        padding: 14px 18px 18px;
        display: grid;
        gap: 10px;
      }
      .tip {
        border: 1px solid var(--line);
        border-radius: 18px;
        padding: 12px 12px;
        background: #fff;
        display: flex;
        gap: 10px;
        align-items: flex-start;
      }
      .tip .dot {
        width: 10px;
        height: 10px;
        border-radius: 999px;
        background: rgba(45, 91, 255, 0.9);
        box-shadow: 0 0 0 4px rgba(45, 91, 255, 0.12);
        margin-top: 4px;
        flex: 0 0 auto;
      }
      .tip b {
        display: block;
        font-size: 13px;
        letter-spacing: -0.02em;
        margin-bottom: 2px;
      }
      .tip span {
        display: block;
        font-size: 12.5px;
        color: var(--muted);
        line-height: 1.45;
      }

      .chat {
        display: flex;
        flex-direction: column;
        min-height: 560px;
      }
      .chatHeader {
        padding: 16px 18px;
        border-bottom: 1px solid var(--line);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        background: rgba(255, 255, 255, 0.85);
        backdrop-filter: blur(8px);
      }
      .chatHeader .left {
        display: flex;
        align-items: center;
        gap: 12px;
        min-width: 0;
      }
      .roomTitle {
        margin: 0;
        font-size: 15px;
        letter-spacing: -0.03em;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .status {
        display: flex;
        align-items: center;
        gap: 8px;
        color: var(--muted);
        font-size: 12.5px;
        white-space: nowrap;
      }
      .pill {
        display: flex;
        gap: 6px;
        align-items: center;
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid var(--line);
        background: #fff;
        box-shadow: var(--shadow-soft);
        font-weight: 700;
        color: var(--text);
        font-size: 12px;
      }
      .led {
        width: 8px;
        height: 8px;
        border-radius: 999px;
        background: #cbd5e1;
      }
      .led.ok {
        background: #22c55e;
        box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.15);
      }
      .led.bad {
        background: #ef4444;
        box-shadow: 0 0 0 4px rgba(239, 68, 68, 0.15);
      }

      .messages {
        padding: 18px;
        flex: 1;
        overflow: auto;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .msgRow {
        display: flex;
        gap: 10px;
        align-items: flex-end;
        max-width: 100%;
      }
      .msgRow.me {
        justify-content: flex-end;
      }
      .msgRow.me .bubble {
        background: linear-gradient(
          135deg,
          rgba(45, 91, 255, 1),
          rgba(0, 225, 255, 0.85)
        );
        color: #fff;
        border: 0;
        box-shadow: 0 12px 30px rgba(45, 91, 255, 0.2);
      }
      .msgRow.me .avatarWrap {
        display: none;
      }

      .avatarWrap {
        width: 40px;
        height: 40px;
        border-radius: 16px;
        border: 1px solid var(--line);
        background: #fff;
        overflow: hidden;
        display: grid;
        place-items: center;
        box-shadow: var(--shadow-soft);
        flex: 0 0 auto;
      }
      .avatarWrap svg {
        width: 40px;
        height: 40px;
      }

      .content {
        min-width: 0;
        max-width: min(560px, 78%);
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .metaLine {
        display: flex;
        gap: 8px;
        align-items: center;
        color: var(--muted);
        font-size: 12px;
      }

      .bubble {
        border: 1px solid var(--line);
        background: #fff;
        border-radius: 18px;
        padding: 11px 12px;
        line-height: 1.45;
        font-size: 13.5px;
        white-space: pre-wrap;
        word-break: break-word;
        box-shadow: var(--shadow-soft);
      }

      .composer {
        padding: 14px;
        border-top: 1px solid var(--line);
        background: rgba(255, 255, 255, 0.92);
        backdrop-filter: blur(10px);
      }

      .bar {
        display: flex;
        gap: 10px;
        align-items: center;
        padding: 10px;
        border: 1px solid var(--line);
        border-radius: 18px;
        background: #fff;
        box-shadow: var(--shadow-soft);
      }

      .bar textarea {
        flex: 1;
        border: 0;
        outline: none;
        resize: none;
        font-size: 13.5px;
        line-height: 1.35;
        min-height: 22px;
        max-height: 120px;
        padding: 4px 2px;
        font-family: inherit;
      }

      .btn {
        border: 0;
        border-radius: 16px;
        padding: 10px 12px;
        font-weight: 800;
        font-size: 13px;
        cursor: pointer;
        background: var(--primary);
        color: #fff;
        box-shadow: 0 14px 30px rgba(45, 91, 255, 0.22);
        display: flex;
        gap: 8px;
        align-items: center;
        transition: transform 0.06s ease, filter 0.12s ease;
        user-select: none;
      }
      .btn:active {
        transform: translateY(1px);
        filter: brightness(0.98);
      }
      .btn:disabled {
        opacity: 0.55;
        cursor: not-allowed;
        box-shadow: none;
      }

      .hint {
        margin-top: 10px;
        display: flex;
        justify-content: space-between;
        gap: 10px;
        color: var(--muted);
        font-size: 12px;
      }
      .kbd {
        font-weight: 800;
        padding: 2px 7px;
        border-radius: 10px;
        border: 1px solid var(--line);
        background: #fff;
        box-shadow: var(--shadow-soft);
        color: var(--text);
      }

      /* Nickname Overlay */
      #nickOverlay {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.55);
        backdrop-filter: blur(6px);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 9999;
        padding: 16px;
      }
      #nickCard {
        width: min(420px, 100%);
        background: #fff;
        border-radius: 22px;
        padding: 26px;
        box-shadow: 0 30px 80px rgba(0, 0, 0, 0.25);
        border: 1px solid rgba(230, 234, 245, 0.9);
      }
      #nickCard h2 {
        margin: 0 0 8px;
        letter-spacing: -0.03em;
        font-size: 18px;
      }
      #nickCard p {
        margin: 0 0 18px;
        color: var(--muted);
        font-size: 13.5px;
        line-height: 1.4;
      }
      #nickInput {
        width: 100%;
        padding: 12px 14px;
        border-radius: 14px;
        border: 1px solid var(--line);
        font-size: 14px;
        outline: none;
      }
      #nickInput:focus {
        border-color: rgba(45, 91, 255, 0.55);
        box-shadow: 0 0 0 4px rgba(45, 91, 255, 0.1);
      }
      #nickConfirm {
        margin-top: 16px;
        width: 100%;
        border: 0;
        border-radius: 16px;
        padding: 12px;
        background: var(--primary);
        color: #fff;
        font-weight: 800;
        font-size: 14px;
        cursor: pointer;
        box-shadow: 0 14px 30px rgba(45, 91, 255, 0.22);
      }
      #nickConfirm:active {
        transform: translateY(1px);
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="app">
        <!-- LEFT -->
        <aside class="panel side">
          <div class="hero">
            <div class="brand">
              <div class="logo">C</div>
              <div>
                <h1>Chat Demo</h1>
                <p>
                  Starlette + WebSocket + Redis broadcast<br />기능은 그대로,
                  UI만 “토스풍”으로.
                </p>
              </div>
            </div>

            <div class="profile">
              <div class="avatar" id="myAvatar"></div>
              <div class="meta">
                <div class="title">
                  <div style="font-weight: 900; letter-spacing: -0.03em">
                    내 프로필
                  </div>
                  <span class="badge">캐릭터</span>
                </div>
                <input
                  id="nickname"
                  placeholder="닉네임 (로컬 표시용)"
                  maxlength="16"
                />
              </div>
            </div>
          </div>

          <div class="tips">
            <div class="tip">
              <div class="dot"></div>
              <div>
                <b>중복 전송 해결</b>
                <span>내 메시지는 “서버에서 돌아올 때”만 1번 렌더링.</span>
              </div>
            </div>
            <div class="tip">
              <div class="dot"></div>
              <div>
                <b>닉네임 진입 화면</b>
                <span>처음 접속 시 닉네임 정하고 입장.</span>
              </div>
            </div>
            <div class="tip">
              <div class="dot"></div>
              <div>
                <b>캐릭터 아바타</b>
                <span>상대 메시지엔 랜덤 캐릭터 프로필.</span>
              </div>
            </div>
          </div>
        </aside>

        <!-- RIGHT -->
        <main class="panel chat">
          <div class="chatHeader">
            <div class="left">
              <div class="pill" title="WebSocket 상태">
                <span class="led bad" id="wsLed"></span>
                <span id="wsText">연결 대기</span>
              </div>
              <h2 class="roomTitle">실시간 채팅</h2>
            </div>
            <div class="status">
              <span>채널</span>
              <span class="kbd">demo</span>
            </div>
          </div>

          <div class="messages" id="messages" aria-live="polite"></div>

          <div class="composer">
            <div class="bar">
              <textarea
                id="input"
                placeholder="메시지 입력… (Enter: 전송 / Shift+Enter: 줄바꿈)"
              ></textarea>
              <button class="btn" id="sendBtn" type="button" disabled>
                <span>전송</span>
                <span aria-hidden="true">➜</span>
              </button>
            </div>
            <div class="hint">
              <span
                >내 메시지 <span class="kbd">오른쪽</span> / 상대
                <span class="kbd">왼쪽</span></span
              >
              <span>연결은 닉네임 입력 후 시작.</span>
            </div>
          </div>
        </main>
      </div>
    </div>

    <!-- Nickname Overlay -->
    <div id="nickOverlay">
      <div id="nickCard">
        <h2>닉네임을 입력해주세요</h2>
        <p>
          채팅에서 표시될 이름이에요. 서버에는 저장되지 않고 브라우저에만
          저장돼요.
        </p>
        <input id="nickInput" placeholder="예: 햄찌왕" maxlength="16" />
        <button id="nickConfirm">입장하기</button>
      </div>
    </div>

    <script>
      // ====== 캐릭터 아바타(SVG) ======
      const avatarSvgs = [
        // 햄찌
        (seed) => `
        <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
          <defs>
            <linearGradient id="g${seed}" x1="0" y1="0" x2="1" y2="1">
              <stop offset="0" stop-color="rgba(45,91,255,.95)"/>
              <stop offset="1" stop-color="rgba(0,225,255,.85)"/>
            </linearGradient>
          </defs>
          <rect width="64" height="64" rx="18" fill="url(#g${seed})" opacity=".12"/>
          <circle cx="32" cy="35" r="18" fill="#FFF" opacity=".95"/>
          <circle cx="24" cy="20" r="7" fill="#FFF" opacity=".95"/>
          <circle cx="40" cy="20" r="7" fill="#FFF" opacity=".95"/>
          <circle cx="26" cy="33" r="2.2" fill="#0F172A"/>
          <circle cx="38" cy="33" r="2.2" fill="#0F172A"/>
          <path d="M30 38c2 2 2 2 4 0" stroke="#0F172A" stroke-width="2" stroke-linecap="round"/>
          <path d="M24 41c2.5 2 5 3 8 3s5.5-1 8-3" stroke="rgba(45,91,255,.75)" stroke-width="2" stroke-linecap="round" fill="none"/>
          <circle cx="20" cy="36" r="3.5" fill="rgba(45,91,255,.18)"/>
          <circle cx="44" cy="36" r="3.5" fill="rgba(0,225,255,.18)"/>
        </svg>
      `,
        // 토끼
        (seed) => `
        <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
          <rect width="64" height="64" rx="18" fill="rgba(155,81,224,.10)"/>
          <path d="M22 20c-2-10 4-14 8-5" stroke="rgba(45,91,255,.55)" stroke-width="6" stroke-linecap="round"/>
          <path d="M42 20c2-10-4-14-8-5" stroke="rgba(0,225,255,.55)" stroke-width="6" stroke-linecap="round"/>
          <circle cx="32" cy="36" r="18" fill="#fff" opacity=".95"/>
          <circle cx="26" cy="35" r="2.2" fill="#0F172A"/>
          <circle cx="38" cy="35" r="2.2" fill="#0F172A"/>
          <path d="M30 40c2 2 2 2 4 0" stroke="#0F172A" stroke-width="2" stroke-linecap="round"/>
          <path d="M26 44c2 2 4 3 6 3s4-1 6-3" stroke="rgba(155,81,224,.65)" stroke-width="2" stroke-linecap="round" fill="none"/>
        </svg>
      `,
        // 고양이
        (seed) => `
        <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
          <rect width="64" height="64" rx="18" fill="rgba(45,91,255,.09)"/>
          <path d="M18 28l6-8 4 7" fill="#fff" opacity=".95"/>
          <path d="M46 28l-6-8-4 7" fill="#fff" opacity=".95"/>
          <circle cx="32" cy="38" r="18" fill="#fff" opacity=".95"/>
          <circle cx="26" cy="37" r="2.2" fill="#0F172A"/>
          <circle cx="38" cy="37" r="2.2" fill="#0F172A"/>
          <path d="M32 40l-2 2h4z" fill="#0F172A"/>
          <path d="M20 40c4 0 6 1 8 2" stroke="rgba(45,91,255,.55)" stroke-width="2" stroke-linecap="round"/>
          <path d="M44 40c-4 0-6 1-8 2" stroke="rgba(0,225,255,.55)" stroke-width="2" stroke-linecap="round"/>
        </svg>
      `,
        // 펭귄
        (seed) => `
        <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
          <rect width="64" height="64" rx="18" fill="rgba(0,225,255,.10)"/>
          <ellipse cx="32" cy="38" rx="16" ry="18" fill="#0F172A" opacity=".92"/>
          <ellipse cx="32" cy="42" rx="10" ry="12" fill="#fff" opacity=".95"/>
          <circle cx="27" cy="34" r="2.2" fill="#fff"/>
          <circle cx="37" cy="34" r="2.2" fill="#fff"/>
          <path d="M30 38h4l-2 3z" fill="rgba(255, 196, 0, .95)"/>
        </svg>
      `,
      ];

      const seed = () => Math.random().toString(16).slice(2, 7);

      // ====== Local keys ======
      const myAvatarKey = "chat_demo_my_avatar";
      const myAvatarSeedKey = "chat_demo_my_avatar_seed";
      const myNickKey = "chat_demo_nick";

      // 내 아바타 고정(새로고침해도 유지)
      const myAvatarIndex = Number(localStorage.getItem(myAvatarKey) ?? -1);
      const myAvatarSeed = localStorage.getItem(myAvatarSeedKey) ?? seed();
      const chosenIndex =
        myAvatarIndex >= 0
          ? myAvatarIndex
          : Math.floor(Math.random() * avatarSvgs.length);
      localStorage.setItem(myAvatarKey, String(chosenIndex));
      localStorage.setItem(myAvatarSeedKey, myAvatarSeed);

      // DOM refs
      const wsLed = document.getElementById("wsLed");
      const wsText = document.getElementById("wsText");
      const messagesEl = document.getElementById("messages");
      const inputEl = document.getElementById("input");
      const sendBtn = document.getElementById("sendBtn");
      const nicknameEl = document.getElementById("nickname");
      const myAvatarEl = document.getElementById("myAvatar");

      // overlay refs
      const overlay = document.getElementById("nickOverlay");
      const nickInput = document.getElementById("nickInput");
      const nickConfirm = document.getElementById("nickConfirm");

      // init avatar + nickname input (side)
      myAvatarEl.innerHTML = avatarSvgs[chosenIndex](myAvatarSeed);
      nicknameEl.value = localStorage.getItem(myNickKey) ?? "";
      nicknameEl.addEventListener("input", () => {
        localStorage.setItem(myNickKey, nicknameEl.value.trim());
      });

      // ====== utils ======
      function setWsState(ok, text) {
        wsLed.classList.toggle("ok", ok);
        wsLed.classList.toggle("bad", !ok);
        wsText.textContent = text;
        sendBtn.disabled = !ok;
      }

      function scrollToBottom() {
        messagesEl.scrollTop = messagesEl.scrollHeight;
      }

      function escapeHtml(s) {
        return s.replace(
          /[&<>"']/g,
          (m) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#039;",
            }[m])
        );
      }

      function nowTime() {
        const d = new Date();
        const hh = String(d.getHours()).padStart(2, "0");
        const mm = String(d.getMinutes()).padStart(2, "0");
        return `${hh}:${mm}`;
      }

      // 상대 아바타: 텍스트별로 고정처럼 보이게(간단 매핑)
      const otherAvatars = new Map();
      const getOtherAvatar = (key) => {
        if (!otherAvatars.has(key)) {
          const idx = Math.floor(Math.random() * avatarSvgs.length);
          otherAvatars.set(key, avatarSvgs[idx](seed()));
        }
        return otherAvatars.get(key);
      };

      function addMessage({ text, me = false }) {
        const nick = (nicknameEl.value || "나").trim();
        const time = nowTime();
        const safe = escapeHtml(text);

        const row = document.createElement("div");
        row.className = "msgRow" + (me ? " me" : "");

        const avatarWrap = document.createElement("div");
        avatarWrap.className = "avatarWrap";
        avatarWrap.innerHTML = me ? "" : getOtherAvatar(text);

        const content = document.createElement("div");
        content.className = "content";

        const bubble = document.createElement("div");
        bubble.className = "bubble";
        bubble.innerHTML = safe;

        if (me) {
          const tiny = document.createElement("div");
          tiny.className = "metaLine";
          tiny.style.justifyContent = "flex-end";
          tiny.innerHTML = `<span style="font-weight:900; color: rgba(45,91,255,.75);">${escapeHtml(
            nick
          )}</span><span>·</span><span>${time}</span>`;
          content.appendChild(bubble);
          content.appendChild(tiny);
        } else {
          const meta = document.createElement("div");
          meta.className = "metaLine";
          meta.innerHTML = `<span style="font-weight:900; color: var(--text); letter-spacing:-.02em;">상대</span><span>·</span><span>${time}</span>`;
          content.appendChild(meta);
          content.appendChild(bubble);
        }

        if (!me) row.appendChild(avatarWrap);
        row.appendChild(content);

        messagesEl.appendChild(row);
        scrollToBottom();
      }

      // ====== WebSocket ======
      const scheme = location.protocol === "https:" ? "wss" : "ws";
      const wsUrl = `${scheme}://${location.host}/`;
      let ws;

      // 내가 보낸 메시지는 "서버에서 돌아올 때"만 1번 렌더링하기 위한 큐
      const pendingMine = []; // { text, at }
      const PENDING_TTL_MS = 30_000;

      function connect() {
        setWsState(false, "연결 중…");
        ws = new WebSocket(wsUrl);

        ws.onopen = () => setWsState(true, "연결됨");
        ws.onclose = () => setWsState(false, "연결 끊김");
        ws.onerror = () => setWsState(false, "연결 오류");

        ws.onmessage = (ev) => {
          const text = (ev.data ?? "").toString();

          // pending 정리
          const now = Date.now();
          while (
            pendingMine.length &&
            now - pendingMine[0].at > PENDING_TTL_MS
          ) {
            pendingMine.shift();
          }

          // 내가 보낸 메시지면 "내 메시지"로 1번만 표시
          const idx = pendingMine.findIndex((m) => m.text === text);
          if (idx !== -1) {
            pendingMine.splice(idx, 1);
            addMessage({ text, me: true });
            return;
          }

          // 나머지는 상대
          addMessage({ text, me: false });
        };

        // 안내 메시지 1번
        addMessage({
          text: "닉네임 설정 끝났으면 이제 Enter로 전송하면 됨. (Shift+Enter는 줄바꿈)",
          me: false,
        });
      }

      function send() {
        const text = (inputEl.value || "").trim();
        if (!text) return;
        if (!ws || ws.readyState !== WebSocket.OPEN) return;

        // 화면에 즉시 찍지 않는다(중복 방지). 서버 에코로만 1번 찍음.
        pendingMine.push({ text, at: Date.now() });
        ws.send(text);

        inputEl.value = "";
        inputEl.style.height = "auto";
        inputEl.focus();
      }

      sendBtn.addEventListener("click", send);

      inputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          send();
        }
      });

      // textarea auto-grow
      inputEl.addEventListener("input", () => {
        inputEl.style.height = "auto";
        inputEl.style.height = Math.min(inputEl.scrollHeight, 120) + "px";
      });

      // ====== Nickname overlay flow ======
      function ensureNickname() {
        const saved = (localStorage.getItem(myNickKey) ?? "").trim();
        if (saved) {
          overlay.style.display = "none";
          nicknameEl.value = saved;
          connect();
        } else {
          overlay.style.display = "flex";
          nickInput.value = "";
          nickInput.focus();
          setWsState(false, "닉네임 필요");
        }
      }

      nickConfirm.addEventListener("click", () => {
        const val = nickInput.value.trim();
        if (!val) return;
        localStorage.setItem(myNickKey, val);
        nicknameEl.value = val;
        overlay.style.display = "none";
        connect();
      });

      nickInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          nickConfirm.click();
        }
      });

      // 최초 진입
      ensureNickname();
    </script>
  </body>
</html>
